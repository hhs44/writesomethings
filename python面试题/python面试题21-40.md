

[TOC]

# 基础续

## 21. 闭包(closure)



**闭包无法修改外部函数的局部变量**。

**python循环中不包含域的概念**

闭包可以保存当前的运行环境，

闭包避免了使用全局变量，此外，闭包允许将函数与其所操作的某些数据（环境）关连起来。这一点与面向对象编程是非常类似的，在面对象编程中，对象允许我们将某些数据（对象的属性）与一个或者多个方法相关联。

所有函数都有一个 `__closure__`属性，如果这个函数是一个闭包的话，那么它返回的是一个由 cell 对象 组成的元组对象。cell 对象的cell_contents 属性就是闭包中的自由变量。、

简单的说，可以将闭包理解为**能够读取其他函数内部变量的函数**。

## 21.鸭子类型和猴子补丁

猴子补丁：

仅指在运行时动态改变类或模块，为的是将第三方代码打补丁在不按预期运行的bug或者feature上 。在运行时动态修改模块、类或函数，通常是添加功能或修正缺陷。猴子补丁在代码运行时内存中发挥作用，不会修改源码，因此只对当前运行的程序实例有效。因为猴子补丁破坏了封装，而且容易导致程序与补丁代码的实现细节紧密耦合，所以被视为临时的变通方案，不是集成代码的推荐方式。

热补丁。。。。。

鸭子类型：

鸭子类型是动态语言判断一个对象是否是某种类型时使用的方法，也叫做鸭子判定法。

Python语言中，有很多bytes-like对象（如：`bytes`、`bytearray`、`array.array`、`memoryview`）、file-like对象（如：`StringIO`、`BytesIO`、`GzipFile`、`socket`）、path-like对象（如：`str`、`bytes`），其中file-like对象都能支持`read`和`write`操作，可以像文件一样读写，这就是所谓的对象有鸭子的行为就可以判定为鸭子的判定方法。再比如Python中列表的`extend`方法，它需要的参数并不一定要是列表，只要是可迭代对象就没有问题。

## 22.面对对象设计原则

1. 单一职责原则（SRP）：一个类只有必要的属性和方法，一个函数只做好一件事情，高内聚
2. 开闭原则（OCP） -对推展开放，对修改关闭，抽象
3. 依赖倒转原则 （DIP）-面向抽象编程，面向接口编程-尽可能的使用抽象类型让系统有拓展性
4. 里氏替换（LSP） -能够用父类的地方一定可以使用字类型
5. 接口隔离（ISP） - 
6. 合成聚合复用原则（CARP） - 有限使用强关联而不是继承关系复用代码
7. 迪米特法则（LOD） -不要更陌生人讲话，低耦合

SOLID原则 = SRP + OCP + LSP + ISP + LoD

**面向对象：**面向对象编程简单来说就是基于对 类 和 对象 的使用，所有的代码都是通过类和对象来实现的编程就是面向对象编程！面向对象的三大特性：封装、继承、多态

## 23.python中的反射

在反射机制就是在运行时，动态的确定对象的类型，并可以通过字符串调用对象属性、方法、导入模块，是一种基于字符串的事件驱动。通过字符串的形式，去模块寻找指定函数，并执行。利用字符串的形式去对象（模块）中操作（查找/获取/删除/添加）成员。

Python是一门解释型语言，因此对于反射机制支持很好。在Python中支持反射机制的函数有getattr()、setattr()、delattr()、exec()、eval()、__import__，这些函数都可以执行字符串。

## 24.python中的自省的方法

**运行时能够获知对象的类型。**

type()，判断对象类型

dir()， 带参数时获得该对象的所有属性和方法；不带参数时，返回当前范围内的变量、方法和定义的类型列表

help() ,  用于查看函数或模块用途的详细说明

isinstance()，判断对象是否是已知类型

issubclass()，判断一个类是不是另一个类的子类

hasattr()，判断对象是否包含对应属性

getattr()，获取对象属性

setattr()， 设置对象属性

id(): 用于获取对象的内存地址

callable()：判断对象是否可以被调用。

## 25.python中的魔法方法

| 魔法方法                                                     | 作用               |
| ------------------------------------------------------------ | ------------------ |
| `__new__`,`__init__`,`__del__`                               | 创建和销毁对象相关 |
| `__add__`,`__sub__`,`__mul__`,<br />`__div__`,`__floordiv__`，`__mod__` | 算术运算符相关     |
| `__eq__`,`__ne__`,`__lt__`,<br />`__gt__`,`__le__`,`__ge__`  | 关系运算符         |
| `__pos__`,`__neg__`,`__invert__`                             | 一元运算符         |
| `_lshift__`,`__rshift__`,`__and__`<br />`__or__`,`__xor__`   | 位运算             |
| `__enter__`,`__exit__`                                       | 上下文管理器协议   |
| `__iter__`,`__next__`,`__reversed__`                         | 迭代器协议         |
| `__int__`,`__long__`,`__float__`<br />`__oct__`,`__hex__`    | 类型/进制转换      |
| `__str__`,`__repr__`,`__hash__`<br />`__dir__`               | 对象表述相关       |
| `__len__`,`__getitem__`,`__setitem__`<br />`__contains__`,`__missing__` | 序列相关           |
| `__copy__`,`__deepcopy__`                                    | 对象拷贝相关       |
| `__call__`,`__setattr__`,`__getattr__`<br />`__delattr__`    | 其他               |

## 26.函数参数`*arg`和`**kwargs`分别代表什么？

函数的参数分为位置参数、可变参数、关键字参数、命名关键字参数。

*arg代表可变参数，可以接受0个或任意多个参数，参数会被打包成一个元组

**kwargs代表关键字参数，可以接受用参数名=参数值的方式传入参数，传入的参数会打包成一个字典

## 27.python中变量的作用域

Python中有四种作用域，分别是局部作用域（**L**ocal）、嵌套作用域（**E**mbedded）、全局作用域（**G**lobal）、内置作用域（**B**uilt-in），搜索一个标识符时，会按照**LEGB**的顺序进行搜索，如果所有的作用域中都没有找到这个标识符，就会引发`NameError`异常。

## 28.random模块生成随机数、实现随机乱序和水机抽样

+ random.random()函数可以生成[0.0, 1.0)之间的随机浮点数。
+ random.uniform(a, b)函数可以生成[a, b]或[b, a]之间的随机浮点数。
+ random.randint(a, b)函数可以生成[a, b]或[b, a]之间的随机整数。
+ random.shuffle(x)函数可以实现对序列x的原地随机乱序。
+ random.choice(seq)函数可以从非空序列中取出一个随机元素。
+ random.choices(population, weights=None, *, cum_weights=None, k=1)函数可以从总体中随机抽取（有放回抽样）出容量为k的样本并返回样本的列表，可以通过参数指定个体权重，如果没有指定权重，个体被选中的概率均等。
+ random.sample(population, k)函数可以从总体中随机抽取（无放回抽样）出容量为k的样本并返回样本的列表。
+ 



## 29.举例说明什么情况下会出现`KeyError`、`TypeError`、`ValueError`。

举一个简单的例子，变量`a`是一个字典，执行`int(a['x'])`这个操作就有可能引发上述三种类型的异常。如果字典中没有键`x`，会引发`KeyError`；如果键`x`对应的值不是`str`、`float`、`int`、`bool`以及`bytes-like`类型，在调用`int`函数构造`int`类型的对象时，会引发`TypeError`；如果`a[x]`是一个字符串或者字节串，而对应的内容又无法处理成`int`时，将引发`ValueError`。

## 30.如何读取大文件，例如内存只有4G，如何读取一个大小为8G的文件？

很显然4G内存要一次性的加载大小为8G的文件是不现实的，遇到这种情况必须要考虑多次读取和分批次处理。在Python中读取文件可以先通过`open`函数获取文件对象，在读取文件时，可以通过`read`方法的`size`参数指定读取的大小，也可以通过`seek`方法的`offset`参数指定读取的位置，这样就可以控制单次读取数据的字节数和总字节数。除此之外，可以使用内置函数`iter`将文件对象处理成迭代器对象，每次只读取少量的数据进行处理，代码大致写法如下所示。

```python
with open('...', 'rb') as file:
    for data in iter(lambda: file.read(2097152), b''):
        pass
```

## 31.对模块和包的理解

每个python文件就是一个模块，而保存这些文件的文件夹就是一个包，包里包含一个`__init__.py`，包里还有子包的情况下子包中`__init__.py`不是必须的