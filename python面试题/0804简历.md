[TOC]

# 表诉部分

## 自我介绍

1、个人信息：姓名，求职意向

2、介绍上家公司的业务，自己在公司负责的部分

3、做过的项目，使用的主要技术

# 简历问题部分

## 1、python基础？？

+ 魔法方法
+ 迭代器，生成器，装饰器
+ 内置库
+ 面对对象

## 2、良好的编码规范？？

+ pep8规范，常见pep8规范
+ 代码检测工具Flake8，Pylint等

## 3、mvc和mtv含义区别联系？？？

mvc是m（model：数据存取层,view：系操作数据显示的部分，controller：控制用户的访问模块，决定使用视图的那个部分）：

特点：把业务逻辑、模型数据、用户界面离开，使得数据和表现解耦合

mtv（models：数据存储层，templates：表现层，view：业务逻辑层，）

区别：

mvc中view的目的是为了呈现哪一个数据，而 mtv中view是表达数据如何进行呈现，相当于mvc中的view被分成视图和模板两个部分，contral中的url分发被拆分，

mtv中view=mvc中view+mvc中c的url分发器

## 4、restfulapi的含义

REST-REpresentational State Transfer：表现状态转移。

+ url定义资源，用HTTP动词（GET，POST，DELETE，DETC）描述操作
+ Server提供的RESTful API中，URL中只使用名词来指定资源，原则上不使用动词。
+ GET 用来获取资源，
  POST 用来新建资源（也可以用于更新资源），
  PUT 用来更新资源，
  DELETE 用来删除资源
+ Server和Client之间传递某资源的一个表现形式
+ 用 HTTP Status Code传递Server的状态信息。比如最常用的 200 表示成功，500 表示Server内部错误等。



### 新理解：

1. 对同一表进行数据操作，应该使用一条api

2. 面向资源编程，API的参数最好是名词

3. 体现版本号，添加v1/v2等版本代号

4. 体现API让使用者一眼看出这是API而不是url，因该加入提示

   如： api/v1/name

5. 使用HTTPS

6. 响应式设置状态码

7. API参数中加入筛选条件参数，可以理解为火炬资源优先选择GET的方式

8. 返回值的规范不同的method操作成功后，返回值

   + GET：所有列表
   + POST：新增的数据
   + GET：单挑数据
   + PUT：更新，返回更新的数据
   + PATCH：局部更新，返回更新的数据
   + DELETE：删除，返回空文档

9. 返回错误信息，加入错误代码code

10. 返回详细信息，字典的形式放在data里



## 5、四个框架的比较

## 6、mysql相关

### mysql基础

+ 引擎：
  + innodb存储引擎：
    + 事务数据库的首选引擎，支持事务安全表（提交、回滚、崩溃恢复能力），增加了多用户部署和性能。
    + 他的表和索引在一个逻辑表空间中，表空间中可以包含数个文件。
    + 支持外键完整性约束
  + myisam存储引擎
    + 不支持事务
  + memory存储引擎：
    + 可以将表中数据存储到内存中

### mysql优化

+ 配置文件的优化
+ 应用中的优化
  + 建立索引
    + 建立索引为啥快
      + 索引类似一本书的目录
      + 每个索引其实都是一个B+树，主键索引称作聚簇索引，其他非主键索引称作二级索引，每个表中每一行记录值都完整的保存在主键索引的叶子节点上，二级索引的叶子节点保存的是主键的值
  + 慢查询优化
+ 程序框架中的优化
  + djangi中的优化n+1查询，低效率查询

## 7、常见linux命令？？

+ ps，grep，-scp，ipconfig，top，free，mpstat，netstats，pmap

# 8、docker的常见命令



# 9、es部分



## 10、vue对接接口

+ fetch

## 11、swagger在线使用，rap2平台的使用



# 12、celery相关

+ https://blog.csdn.net/ThinkWon/article/details/104588612

# 13、监控工具

## 14、短信和邮件是否冲突，两者内容

## 15、es为什么会提高

### 倒排索引为什么比B-Tree快？

+ 倒排索引将内容里的关键字作为索引



# 16、使用es封装的接口包含

## 17、热门数据的更新实现

## 18、螺丝帽流程

# 19、jwt相关

+  JWT是由三段信息构成的,第一部分我们称它为头部（header),第二部分我们称其为载荷（payload, 类似于飞机上承载的物品)，第三部分是签证（signature)

+ 过程

  + 首先，前端通过Web表单将自己的用户名和密码发送到后端的接口。这一过程一般是一个HTTP POST请求。建议的方式是通过SSL加密的传输（https协议），从而避免敏感信息被嗅探。
  + 后端核对用户名和密码成功后，将用户的id等其他信息作为JWT Payload（负载），将其与头部分别进行Base64编码拼接后签名，形成一个JWT。形成的JWT就是一个形同lll.zzz.xxx的字符串。
  + 后端将JWT字符串作为登录成功的返回结果返回给前端。前端可以将返回的结果保存在localStorage或sessionStorage上，退出登录时前端删除保存的JWT即可。
  + 前端在每次请求时将JWT放入HTTP Header中的Authorization位。(解决XSS和XSRF问题）

  ​    5.后端检查是否存在，如存在验证JWT的有效性。例如，检查签名是否正确；检查Token是否过期；检查Token的接收方是否是自己（可选）。

+ 优点

  + 因为json的通用性，所以JWT是可以进行跨语言支持的。
  + 因为有了payload部分，所以JWT可以在自定义一些参数，非敏感信息。
  + 便于传输，的构成非常简单，字节占用很小，所以它是非常便于传输的。
  + jwt不需要在服务端保存会话信息, 易于应用的扩展。

+ 缺点：

  - 登录状态信息续签问题。比如设置token的有效期为一个小时，那么一个小时后，如果用户仍然在这个web应用上，这个时候当然不能指望用户再登录一次。目前可用的解决办法是在每次用户发出请求都返回一个新的token，前端再用这个新的token来替代旧的，这样每一次请求都会刷新token的有效期。但是这样，需要频繁的生成token。另外一种方案是判断还有多久这个token会过期，在token快要过期时，返回一个新的token。
  - **注销登录等场景下 token 还有效**：
    - **黑名单机制**：和上面的方式类似，使用内存数据库比如 redis 维护一个黑名单，如果想让某个 token 失效的话就直接将这个 token 加入到 黑名单 即可。然后，每次使用 token 进行请求的话都会先判断这个 token 是否存在于黑名单中。
    - **修改密钥 (Secret)** : 我们为每个用户都创建一个专属密钥，如果我们想让某个 token 失效，我们直接修改对应用户的密钥即可。但是，这样相比于前两种引入内存数据库带来了危害更大，比如：(1).如果服务是分布式的，则每次发出新的 token 时都必须在多台机器同步密钥。为此，你需要将必须将机密存储在数据库或其他外部服务中，这样和 Session 认证就没太大区别了。(2).如果用户同时在两个浏览器打开系统，或者在手机端也打开了系统，如果它从一个地方将账号退出，那么其他地方都要重新进行登录，这是不可取的。
      保持令牌的有效期限短并经常轮换 ：很简单的一种方式。但是，会导致用户登录状态不会被持久记录，而且需要用户经常登录。
  - **token 的续签问题**
    - 假设服务端给的 token 有效期设置为30分钟，服务端每次进行校验时，如果发现 token 的有效期马上快过期了，服务端就重新生成 token 给客户端。客户端每次请求都检查新旧token，如果不一致，则更新本地的token。这种做法的问题是仅仅在快过期的时候请求才会更新 token ,对客户端不是很友好。
    - 用户登录返回两个 token ：第一个是 acessToken ，它的过期时间 token 本身的过期时间比如半个小时，另外一个是 refreshToken 它的过期时间更长一点比如为1天。客户端登录后，将 accessToken和refreshToken 保存在本地，每次访问将 accessToken 传给服务端。服务端校验 accessToken 的有效性，如果过期的话，就将 refreshToken 传给服务端。如果有效，服务端就生成新的 accessToken 给客户端。否则，客户端就重新登录即可。该方案的不足是：(1).需要客户端来配合；(2).用户注销的时候需要同时保证两个 token 都无效；(3).重新请求获取 token 的过程中会有短暂 token 不可用的情况（可以通过在客户端设置定时器，当accessToken 快过期的时候，提前去通过 refreshToken 获取新的accessToken）。

## 20、docker部署



## 21、drf新理解

### 常用组件：

+ 权限组件
+ 认证组件
+ 访问频率限制组件
+ 序列化组件
+ 路由组件
+ 视图组件
+ 分页组件
+ 解析器组件
+ 渲染器组件
+ 版本组件